---
title: Python Cryptography
permalink: /assignments/pa2_5_crypto
key: assignments-pa2_5_crypto
layout: article
nav_key: assignments
sidebar:
  nav: assignments
license: false
aside:
  toc: true
show_edit_on_github: false
show_date: false
---

The Python [`cryptography`](https://pypi.org/project/cryptography/) module is pretty straightforward to use. We will highlight here a few methods that are necessary for this assignment to save your time. 

> You can install the `cryptography` module using `pip`: `python3.10 -m pip install cryptography`. Make sure that it is installed to your `Python3.10` and not your previous versions of Python, that is to call the `pip` with the `python3.10` version (make sure its in `$PATH`, no other alias, etc). If you don't know how to manage your modules for different versions of Python, please Google harder and try to understand how things are *installed* in your computer from your knowledge about the OS and the File System. We are *way* past this right now. 


### Key Generation
In `/source/auth/generate_keys.py`, we have provided you with instructions on how to generate 1024-bit RSA key pair. You can run the script as such:
```
python3 ./source/auth/generate_keys.py server
```

Two files will be produced:
1. `server_private_key.pem`: private key for server program (note that private key file also contain public key information as well)
2. `server_csr.pem`: certificate signing request file, to be sent to our CA bot for signing purposes. The CA will return a `.crt` file containing the server's public key. 

Do not change the names of the files generated by `generate_keys.py`. 
{:.error}

### Reading Certificate
You can extract a public key from a `.crt` file. For instance, we give you `cacsertificate.crt` file containing our CA's public key. You can use the CA public key later on to <span style="color:#f77729;"><b>verify</b></span> the authenticity of the certificate sent by the server. 

First, you can open the `.crt` file as per normal as `bytes` data type, 
```python
from cryptography import x509
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.backends import default_backend

f = open("auth/cacsertificate.crt", "rb")
ca_cert_raw = f.read()
```

Then use the `x509` method to load it:
```python
ca_cert = x509.load_pem_x509_certificate(
    data=ca_cert_raw, backend=default_backend()
)
```

Afterwards, you can get a public key from the certificate:
```python
ca_public_key = ca_cert.public_key()
```

### Verify signature
You can use a <span style="color:#f77729;"><b>public key</b></span> to verify any signature data. For instance, suppose you have `server_cert_raw` byte data, containing the information about the <span style="color:#f77729;"><b>signed</b></span> server certificate by the CA. You can <span style="color:#f77729;"><b>verify</b></span> that this `server_cert_raw` is <span style="color:#f77729;"><b>indeed</b></span> issued by the CA using the `verify` method:
```python
server_cert = x509.load_pem_x509_certificate(
    data=server_cert_raw, backend=default_backend()
)

ca_public_key.verify(
    signature=server_cert.signature, # signature bytes to  verify
    data=server_cert.tbs_certificate_bytes, # certificate data bytes that was signed by CA
    padding=padding.PKCS1v15(), # padding used by CA bot to sign the the server's csr
    algorithm=server_cert.signature_hash_algorithm,
)
```

An `InvalidSignature` exception will be <span style="color:#f77729;"><b>raised</b></span> if the signature fails to verify. Otherwise, the instructions will continue.
{:.warning}

### Reading a .pem file
You can <span style="color:#f77729;"><b>extract</b></span> both the private key and public key from the `.pem` file generated by `generate_keys.py`. The password used is `passphrase` by default. 
```python
try:
    with open("auth/server_private_key.pem", mode="r", encoding="utf8") as key_file:
        private_key = serialization.load_pem_private_key(
            bytes(key_file.read(), encoding="utf8"), password=b"passphrase"
        )
    public_key = private_key.public_key()
except Exception as e:
    print(e)

# Use private_key or public_key for encryption or decryption from now onwards
```


### Sign Message and Verify
We <span style="color:#f77729;"><b>sign</b></span> a message by encrypting it with our `private_key`. For instance,
```python
message = bytes("hello world", encoding="utf-8")
private_key.sign(
        message, # message in bytes format
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH,
        ),
        hashes.SHA256(), # hashing algorithm used to hash the data before encryption
    )
```

We can then verify the `message` using the `verify` method that we have seen above with the <span style="color:#f7007f;"><b>corresponding</b></span> `public_key`:
```python
public_key.verify(
    file_data,
    nonce,
    padding.PSS(
        mgf=padding.MGF1(hashes.SHA256()),
        salt_length=padding.PSS.MAX_LENGTH,
    ),
    hashes.SHA256(),
)
```

Note that in the above example, `SHA256` is used to <span style="color:#f77729;"><b>hash</b></span> the `message` first before encrypting it with `private_key`. 

The padding used for the example above is [`PSS`](https://en.wikipedia.org/wiki/Probabilistic_signature_scheme). It is a <span style="color:#f77729;"><b>new signature padding scheme</b></span> standard that should be used to pad <span style="color:#f77729;"><b>signatures</b></span> securely. You may read more about it [here](https://www.cryptosys.net/pki/manpki/pki_rsaschemes.html) but it is out of our syllabus scope.


Note that in the above `ca_public_key.verify` example, we used the old `padding.PKCS1v15()` because that's just how our CA bot signed the `.csr`, however when our server signs the client's message, it can use the more advanced `PSS` padding. Conversely, the client <span style="color:#f77729;"><b>must</b></span> also use `PSS` padding if the server used it to pad the digital signature. 


### Standard Encryption
You can <span style="color:#f77729;"><b>encrypt</b></span> a message with a `public_key`. 
> In the section above, you encrypt a message with a `private_key`, and we call this <span style="color:#f7007f;"><b>signing</b></span> instead. 

```python
message = bytes("hello world", encoding="utf-8")
encrypted_message = public_key.encrypt(
        message,
        padding.OAEP(
            mgf=padding.MGF1(hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None,
        ),
    )
```

### Padding and Message Size
Note that in the example above, [`OAEP`](https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding) padding scheme is used. This is an RSA <span style="color:#f77729;"><b>encryption padding scheme</b></span> (as opposed to `PSS`, which is a signature padding scheme). 

The <span style="color:#f77729;"><b>minimum</b></span> length of `OAEP` padding is 66 bytes. A `1024` bit RSA keys can at most encrypt 128 bytes of message data chunk at a time. With 66 bytes of padding at minimum this leaves us with 62 bytes of message to encrypt at a time.
{:.error}

If you were to encrypt with `PKCS1v15` instead (min 11 bytes of padding):
```python
encrypted_message = public_key.encrypt(message, padding.PKCS1v15())
```
Then the maximum length of the message to encrypt at a time with 1024 bit RSA key is 117 bytes. 

It is up to you to <span style="color:#f77729;"><b>choose</b></span> which padding implementation to use to encrypt the chunk of messages (file data) sent by client to the server. Just ensure that you set the chunk size accordingly. 

### Standard Decryption
You can <span style="color:#f77729;"><b>decrypt</b></span> a message with a `private_key`.
> Again, you can also decrypt a signed message with a `public_key`, but the keyword used here is `verify` and not standard "decryption". 


```python
decrypted_message = private_key.decrypt(
      encrypted_message, # in bytes
      padding.OAEP(      # padding should match whatever used during encryption
          mgf=padding.MGF1(hashes.SHA256()),
          algorithm=hashes.SHA256(),
          label=None,
      ),
  )
```

### Generating a Symmetric Key
You can generate a symmetric key as <span style="color:#f77729;"><b>session key</b></span> for a better file encryption performance. You can use the [`Fernet`](https://cryptography.io/en/latest/fernet/) method to generate a symmetric key. It is really simple to use:
```python
from cryptography.fernet import Fernet
key = (
    Fernet.generate_key() # generates 128-bit symmetric key as bytes
) 
session_key = Fernet(key) # instantiate a Fernet instance with key
```

### Using a Symmetric Key
Unlike RSA encryption, you can `encrypt` any byte datatype without separating them into chunks: 
```python
long_message = b""
with open("source/files/image.ppm", "rb") as f:
  long_message = f.read()
encrypted_long_message = session_key.encrypt(long_message)
decrypted_long_message = session_key.decrypt(encrypted_long_message)
assert decrypted_long_message == long_message
```





